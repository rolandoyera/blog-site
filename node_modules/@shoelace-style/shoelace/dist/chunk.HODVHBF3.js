// node_modules/@shoelace-style/shoemaker/dist/shoemaker.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function getAttrName(propName) {
  return propName.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).replace(/^-/, "");
}
function getAttrValue(propValue) {
  if (typeof propValue === "string" || typeof propValue === "number") {
    return propValue + "";
  } else if (typeof propValue === "boolean") {
    return propValue ? "" : null;
  } else {
    return null;
  }
}
function getPropName(attrName) {
  return attrName.replace(/-./g, (m) => m.toUpperCase()[1]);
}
function getPropValue(attrValue) {
  if (attrValue === "") {
    return true;
  } else if (Number(attrValue).toString() === attrValue) {
    return Number(attrValue);
  } else {
    return attrValue;
  }
}
var reservedProperties = [
  "accesskey",
  "class",
  "contenteditable",
  "dir",
  "draggable",
  "hidden",
  "id",
  "lang",
  "style",
  "tabindex",
  "title",
  "translate"
];
var umap = (_) => ({
  get: (key) => _.get(key),
  set: (key, value) => (_.set(key, value), value)
});
var attr = /([^\s\\>"'=]+)\s*=\s*(['"]?)$/;
var empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
var node$1 = /<[a-z][^>]+$/i;
var notNode = />[^<>]*$/;
var selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\/>)/ig;
var trimEnd = /\s+$/;
var isNode = (template, i) => 0 < i-- && (node$1.test(template[i]) || !notNode.test(template[i]) && isNode(template, i));
var regular = (original, name, extra) => empty.test(name) ? original : `<${name}${extra.replace(trimEnd, "")}></${name}>`;
var instrument = (template, prefix2, svg2) => {
  const text2 = [];
  const {length} = template;
  for (let i = 1; i < length; i++) {
    const chunk = template[i - 1];
    text2.push(attr.test(chunk) && isNode(template, i) ? chunk.replace(attr, (_, $1, $2) => `${prefix2}${i - 1}=${$2 || '"'}${$1}${$2 ? "" : '"'}`) : `${chunk}<!--${prefix2}${i - 1}-->`);
  }
  text2.push(template[length - 1]);
  const output = text2.join("").trim();
  return svg2 ? output : output.replace(selfClosing, regular);
};
var {isArray} = Array;
var {indexOf, slice} = [];
var ELEMENT_NODE = 1;
var nodeType = 111;
var remove = ({firstChild, lastChild}) => {
  const range = document.createRange();
  range.setStartAfter(firstChild);
  range.setEndAfter(lastChild);
  range.deleteContents();
  return firstChild;
};
var diffable = (node2, operation) => node2.nodeType === nodeType ? 1 / operation < 0 ? operation ? remove(node2) : node2.lastChild : operation ? node2.valueOf() : node2.firstChild : node2;
var persistent = (fragment) => {
  const {childNodes} = fragment;
  const {length} = childNodes;
  if (length < 2)
    return length ? childNodes[0] : fragment;
  const nodes = slice.call(childNodes, 0);
  const firstChild = nodes[0];
  const lastChild = nodes[length - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild,
    lastChild,
    valueOf() {
      if (childNodes.length !== length) {
        let i = 0;
        while (i < length)
          fragment.appendChild(nodes[i++]);
      }
      return fragment;
    }
  };
};
var udomdiff = (parentNode, a, b, get, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (aEnd === aStart) {
      const node2 = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;
      while (bStart < bEnd)
        parentNode.insertBefore(get(b[bStart++], 1), node2);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart]))
          parentNode.removeChild(get(a[aStart], -1));
        aStart++;
      }
    } else if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
    } else if (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node2 = get(a[--aEnd], -1).nextSibling;
      parentNode.insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);
      parentNode.insertBefore(get(b[--bEnd], 1), node2);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = new Map();
        let i = bStart;
        while (i < bEnd)
          map.set(b[i], i++);
      }
      if (map.has(a[aStart])) {
        const index = map.get(a[aStart]);
        if (bStart < index && index < bEnd) {
          let i = aStart;
          let sequence = 1;
          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)
            sequence++;
          if (sequence > index - bStart) {
            const node2 = get(a[aStart], 0);
            while (bStart < index)
              parentNode.insertBefore(get(b[bStart++], 1), node2);
          } else {
            parentNode.replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));
          }
        } else
          aStart++;
      } else
        parentNode.removeChild(get(a[aStart++], -1));
    }
  }
  return b;
};
var aria = (node2) => (values) => {
  for (const key in values) {
    const name = key === "role" ? key : `aria-${key}`;
    const value = values[key];
    if (value == null)
      node2.removeAttribute(name);
    else
      node2.setAttribute(name, value);
  }
};
var attribute = (node2, name) => {
  let oldValue, orphan = true;
  const attributeNode = document.createAttributeNS(null, name);
  return (newValue) => {
    if (oldValue !== newValue) {
      oldValue = newValue;
      if (oldValue == null) {
        if (!orphan) {
          node2.removeAttributeNode(attributeNode);
          orphan = true;
        }
      } else {
        attributeNode.value = newValue;
        if (orphan) {
          node2.setAttributeNodeNS(attributeNode);
          orphan = false;
        }
      }
    }
  };
};
var boolean = (node2, key, oldValue) => (newValue) => {
  if (oldValue !== !!newValue) {
    if (oldValue = !!newValue)
      node2.setAttribute(key, "");
    else
      node2.removeAttribute(key);
  }
};
var data = ({dataset}) => (values) => {
  for (const key in values) {
    const value = values[key];
    if (value == null)
      delete dataset[key];
    else
      dataset[key] = value;
  }
};
var event = (node2, name) => {
  let oldValue, type = name.slice(2);
  if (!(name in node2) && name.toLowerCase() in node2)
    type = type.toLowerCase();
  return (newValue) => {
    const info = isArray(newValue) ? newValue : [newValue, false];
    if (oldValue !== info[0]) {
      if (oldValue)
        node2.removeEventListener(type, oldValue, info[1]);
      if (oldValue = info[0])
        node2.addEventListener(type, oldValue, info[1]);
    }
  };
};
var ref = (node2) => (value) => {
  if (typeof value === "function")
    value(node2);
  else
    value.current = node2;
};
var setter = (node2, key) => key === "dataset" ? data(node2) : (value) => {
  node2[key] = value;
};
var text = (node2) => {
  let oldValue;
  return (newValue) => {
    if (oldValue != newValue) {
      oldValue = newValue;
      node2.textContent = newValue == null ? "" : newValue;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(document2) {
  var FRAGMENT = "fragment";
  var TEMPLATE = "template";
  var HAS_CONTENT = "content" in create2(TEMPLATE);
  var createHTML = HAS_CONTENT ? function(html2) {
    var template = create2(TEMPLATE);
    template.innerHTML = html2;
    return template.content;
  } : function(html2) {
    var content = create2(FRAGMENT);
    var template = create2(TEMPLATE);
    var childNodes = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html2)) {
      var selector = RegExp.$1;
      template.innerHTML = "<table>" + html2 + "</table>";
      childNodes = template.querySelectorAll(selector);
    } else {
      template.innerHTML = html2;
      childNodes = template.childNodes;
    }
    append(content, childNodes);
    return content;
  };
  return function createContent2(markup, type) {
    return (type === "svg" ? createSVG : createHTML)(markup);
  };
  function append(root, childNodes) {
    var length = childNodes.length;
    while (length--)
      root.appendChild(childNodes[0]);
  }
  function create2(element) {
    return element === FRAGMENT ? document2.createDocumentFragment() : document2.createElementNS("http://www.w3.org/1999/xhtml", element);
  }
  function createSVG(svg2) {
    var content = create2(FRAGMENT);
    var template = create2("div");
    template.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + svg2 + "</svg>";
    append(content, template.firstChild.childNodes);
    return content;
  }
}(document);
var reducePath = ({childNodes}, i) => childNodes[i];
var createPath = (node2) => {
  const path = [];
  let {parentNode} = node2;
  while (parentNode) {
    path.push(indexOf.call(parentNode.childNodes, node2));
    node2 = parentNode;
    parentNode = node2.parentNode;
  }
  return path;
};
var {createTreeWalker, importNode} = document;
var isImportNodeLengthWrong = importNode.length != 1;
var createFragment = isImportNodeLengthWrong ? (text2, type, normalize) => importNode.call(document, createContent(text2, type, normalize), true) : createContent;
var createWalker = isImportNodeLengthWrong ? (fragment) => createTreeWalker.call(document, fragment, 1 | 128, null, false) : (fragment) => createTreeWalker.call(document, fragment, 1 | 128);
var diff = (comment, oldNodes, newNodes) => udomdiff(comment.parentNode, oldNodes, newNodes, diffable, comment);
var handleAnything = (comment) => {
  let oldValue, text2, nodes = [];
  const anyContent = (newValue) => {
    switch (typeof newValue) {
      case "string":
      case "number":
      case "boolean":
        if (oldValue !== newValue) {
          oldValue = newValue;
          if (text2)
            text2.nodeValue = newValue;
          else
            text2 = document.createTextNode(newValue);
          nodes = diff(comment, nodes, [text2]);
        }
        break;
      case "function":
        anyContent(newValue(node));
        break;
      case "object":
      case "undefined":
        if (newValue == null) {
          if (oldValue != newValue) {
            oldValue = newValue;
            nodes = diff(comment, nodes, []);
          }
          break;
        }
        if (isArray(newValue)) {
          oldValue = newValue;
          if (newValue.length === 0)
            nodes = diff(comment, nodes, []);
          else if (typeof newValue[0] === "object")
            nodes = diff(comment, nodes, newValue);
          else
            anyContent(String(newValue));
          break;
        }
        if ("ELEMENT_NODE" in newValue && oldValue !== newValue) {
          oldValue = newValue;
          nodes = diff(comment, nodes, newValue.nodeType === 11 ? slice.call(newValue.childNodes) : [newValue]);
        }
    }
  };
  return anyContent;
};
var handleAttribute = (node2, name) => {
  switch (name[0]) {
    case "?":
      return boolean(node2, name.slice(1), false);
    case ".":
      return setter(node2, name.slice(1));
    case "o":
      if (name[1] === "n")
        return event(node2, name);
  }
  switch (name) {
    case "ref":
      return ref(node2);
    case "aria":
      return aria(node2);
  }
  return attribute(node2, name);
};
function handlers(options) {
  const {type, path} = options;
  const node2 = path.reduceRight(reducePath, this);
  return type === "node" ? handleAnything(node2) : type === "attr" ? handleAttribute(node2, options.name) : text(node2);
}
var prefix = "is\xB5";
var cache = umap(new WeakMap());
var textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;
var createCache = () => ({
  stack: [],
  entry: null,
  wire: null
});
var createEntry = (type, template) => {
  const {content, updates} = mapUpdates(type, template);
  return {type, template, content, updates, wire: null};
};
var mapTemplate = (type, template) => {
  const text2 = instrument(template, prefix, type === "svg");
  const content = createFragment(text2, type);
  const tw = createWalker(content);
  const nodes = [];
  const length = template.length - 1;
  let i = 0;
  let search = `${prefix}${i}`;
  while (i < length) {
    const node2 = tw.nextNode();
    if (!node2)
      throw `bad template: ${text2}`;
    if (node2.nodeType === 8) {
      if (node2.nodeValue === search) {
        nodes.push({type: "node", path: createPath(node2)});
        search = `${prefix}${++i}`;
      }
    } else {
      while (node2.hasAttribute(search)) {
        nodes.push({
          type: "attr",
          path: createPath(node2),
          name: node2.getAttribute(search)
        });
        node2.removeAttribute(search);
        search = `${prefix}${++i}`;
      }
      if (textOnly.test(node2.tagName) && node2.textContent.trim() === `<!--${search}-->`) {
        node2.textContent = "";
        nodes.push({type: "text", path: createPath(node2)});
        search = `${prefix}${++i}`;
      }
    }
  }
  return {content, nodes};
};
var mapUpdates = (type, template) => {
  const {content, nodes} = cache.get(template) || cache.set(template, mapTemplate(type, template));
  const fragment = importNode.call(document, content, true);
  const updates = nodes.map(handlers, fragment);
  return {content: fragment, updates};
};
var unroll = (info, {type, template, values}) => {
  const {length} = values;
  unrollValues(info, values, length);
  let {entry} = info;
  if (!entry || (entry.template !== template || entry.type !== type))
    info.entry = entry = createEntry(type, template);
  const {content, updates, wire} = entry;
  for (let i = 0; i < length; i++)
    updates[i](values[i]);
  return wire || (entry.wire = persistent(content));
};
var unrollValues = ({stack}, values, length) => {
  for (let i = 0; i < length; i++) {
    const hole = values[i];
    if (hole instanceof Hole)
      values[i] = unroll(stack[i] || (stack[i] = createCache()), hole);
    else if (isArray(hole))
      unrollValues(stack[i] || (stack[i] = createCache()), hole, hole.length);
    else
      stack[i] = null;
  }
  if (length < stack.length)
    stack.splice(length);
};
function Hole(type, template, values) {
  this.type = type;
  this.template = template;
  this.values = values;
}
var {create, defineProperties} = Object;
var tag = (type) => {
  const keyed = umap(new WeakMap());
  const fixed = (cache2) => (template, ...values) => unroll(cache2, {type, template, values});
  return defineProperties((template, ...values) => new Hole(type, template, values), {
    for: {
      value(ref2, id) {
        const memo = keyed.get(ref2) || keyed.set(ref2, create(null));
        return memo[id] || (memo[id] = fixed(createCache()));
      }
    },
    node: {
      value: (template, ...values) => unroll(createCache(), {type, template, values}).valueOf()
    }
  });
};
var cache$1 = umap(new WeakMap());
var render = (where, what) => {
  const hole = typeof what === "function" ? what() : what;
  const info = cache$1.get(where) || cache$1.set(where, createCache());
  const wire = hole instanceof Hole ? unroll(info, hole) : hole;
  if (wire !== info.wire) {
    info.wire = wire;
    where.textContent = "";
    where.appendChild(wire.valueOf());
  }
  return where;
};
var html = tag("html");
var svg = tag("svg");
var Shoemaker = class extends HTMLElement {
  constructor() {
    super();
    this._initialProps = {};
    this._isInitialized = false;
    this._isMounted = false;
    this._isRenderScheduled = false;
    this._props = {};
    this.attachShadow({mode: "open"});
    const {props} = this.constructor;
    props.map((prop) => {
      if (reservedProperties.includes(prop)) {
        throw new Error(`Invalid prop name: "${prop}" is a reserved property`);
      }
      if (this.hasOwnProperty(prop)) {
        this._initialProps[prop] = this[prop];
      }
      Object.defineProperty(this, prop, {
        get: () => this._props[prop],
        set: (newValue) => {
          const oldValue = this._props[prop];
          this._props[prop] = newValue;
          this._reflectToAttr(prop);
          this.scheduleRender();
          this._triggerWatcher(prop, oldValue, newValue);
        }
      });
    });
  }
  static get observedAttributes() {
    return this.props.map((prop) => getAttrName(prop));
  }
  connectedCallback() {
    const {props} = this.constructor;
    Object.keys(this._initialProps).map((prop) => {
      this[prop] = this._initialProps[prop];
    });
    this._initialProps = {};
    props.map((prop) => {
      const attr2 = getAttrName(prop);
      if (this.hasAttribute(attr2)) {
        this._props[prop] = getPropValue(this.getAttribute(attr2));
      }
    });
    this._isInitialized = true;
    this.onConnect();
    this._isMounted = true;
    this._renderToDOM();
    this.onReady();
  }
  disconnectedCallback() {
    this._isMounted = false;
    this.onDisconnect();
  }
  attributeChangedCallback(attrName, oldValue, newValue) {
    if (newValue !== oldValue && this._isMounted) {
      this._props[getPropName(attrName)] = getPropValue(newValue);
      this.scheduleRender();
    }
  }
  _reflectToAttr(prop) {
    const {reflect} = this.constructor;
    if (reflect.includes(prop) && this._isMounted) {
      const propValue = this._props[prop];
      const attrName = getAttrName(prop);
      const attrValue = getAttrValue(propValue);
      if (typeof attrValue === "string") {
        this.setAttribute(attrName, attrValue);
      } else {
        this.removeAttribute(attrName);
      }
    }
  }
  _triggerWatcher(propertyName, oldValue, newValue) {
    if (newValue !== oldValue && this._isMounted) {
      const methodName = `watch${propertyName.charAt(0).toUpperCase() + propertyName.substring(1)}`;
      if (typeof this.constructor.prototype[methodName] === "function") {
        this.constructor.prototype[methodName].call(this, oldValue, newValue);
      }
    }
  }
  _renderToDOM() {
    const template = this.render();
    if (template) {
      const {styles} = this.constructor;
      const stylesheet = html`<style>
        ${styles}
      </style>`;
      render(this.shadowRoot, html`${stylesheet} ${template}`);
    }
  }
  onConnect() {
  }
  onReady() {
  }
  onDisconnect() {
  }
  render() {
    return void 0;
  }
  scheduleRender() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._isRenderScheduled && this._isMounted) {
        this._isRenderScheduled = true;
        return new Promise((resolve) => requestAnimationFrame(() => {
          if (this._isInitialized) {
            this._renderToDOM();
            this._isRenderScheduled = false;
            resolve(null);
          }
        }));
      }
    });
  }
  emit(eventName, eventOptions) {
    const event2 = new CustomEvent(eventName, Object.assign({
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: {}
    }, eventOptions));
    this.dispatchEvent(event2);
    return event2;
  }
  static register() {
    customElements.define(this.tag, this);
  }
};
Shoemaker.props = [];
Shoemaker.reflect = [];
Shoemaker.styles = "";

export {
  html,
  Shoemaker
};
