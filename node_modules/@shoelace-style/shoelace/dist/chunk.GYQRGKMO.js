import {
  dist_exports
} from "./chunk.FBS5DUDL.js";
import {
  Shoemaker,
  html
} from "./chunk.HODVHBF3.js";

// _ccwmwdlsd:/Users/claviska/Projects/shoelace/src/components/animation/animation.scss
var animation_default = ":host {\n  position: relative;\n  box-sizing: border-box;\n}\n:host *, :host *:before, :host *:after {\n  box-sizing: inherit;\n}\n\n:host {\n  display: contents;\n}";

// src/components/animation/animation.ts
var SlAnimation = class extends Shoemaker {
  constructor() {
    super(...arguments);
    this.hasStarted = false;
    this.name = "none";
    this.delay = 0;
    this.direction = "normal";
    this.duration = 1e3;
    this.easing = "linear";
    this.endDelay = 0;
    this.fill = "auto";
    this.iterations = Infinity;
    this.iterationStart = 0;
    this.playbackRate = 1;
    this.pause = false;
  }
  onReady() {
    this.createAnimation();
  }
  onDisconnect() {
    this.destroyAnimation();
  }
  handleAnimationFinish() {
    this.emit("sl-finish");
  }
  handleAnimationCancel() {
    this.emit("sl-cancel");
  }
  handlePlaybackRateChange() {
    this.animation.playbackRate = this.playbackRate;
  }
  handleSlotChange() {
    this.destroyAnimation();
    this.createAnimation();
  }
  createAnimation() {
    const easing = dist_exports.easings[this.easing] || this.easing;
    const keyframes = this.keyframes ? this.keyframes : dist_exports[this.name];
    const element = this.defaultSlot.assignedElements({flatten: true})[0];
    if (!element) {
      return;
    }
    this.destroyAnimation();
    this.animation = element.animate(keyframes, {
      delay: this.delay,
      direction: this.direction,
      duration: this.duration,
      easing,
      endDelay: this.endDelay,
      fill: this.fill,
      iterationStart: this.iterationStart,
      iterations: this.iterations
    });
    this.animation.playbackRate = this.playbackRate;
    this.animation.addEventListener("cancel", this.handleAnimationCancel);
    this.animation.addEventListener("finish", this.handleAnimationFinish);
    if (this.pause) {
      this.animation.pause();
    } else {
      this.hasStarted = true;
      this.emit("sl-start");
    }
  }
  destroyAnimation() {
    if (this.animation) {
      this.animation.cancel();
      this.animation.removeEventListener("cancel", this.handleAnimationCancel);
      this.animation.removeEventListener("finish", this.handleAnimationFinish);
      this.hasStarted = false;
    }
  }
  watchDelay() {
    this.createAnimation();
  }
  watchDirection() {
    this.createAnimation();
  }
  watchEasing() {
    this.createAnimation();
  }
  watchEndDelay() {
    this.createAnimation();
  }
  watchFill() {
    this.createAnimation();
  }
  watchIterations() {
    this.createAnimation();
  }
  watchIterationStart() {
    this.createAnimation();
  }
  watchKeyframes() {
    this.createAnimation();
  }
  watchName() {
    this.createAnimation();
  }
  watchPause() {
    this.pause ? this.animation.pause() : this.animation.play();
    if (!this.pause && !this.hasStarted) {
      this.hasStarted = true;
      this.emit("sl-start");
    }
  }
  watchPlaybackRate() {
    this.animation.playbackRate = this.playbackRate;
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e) {
    }
  }
  finish() {
    try {
      this.animation.finish();
    } catch (e) {
    }
  }
  getCurrentTime() {
    return this.animation.currentTime;
  }
  setCurrentTime(time) {
    this.animation.currentTime = time;
  }
  render() {
    return html`
      <slot ref=${(el) => this.defaultSlot = el} onslotchange=${this.handleSlotChange.bind(this)} />
    `;
  }
};
SlAnimation.tag = "sl-animation";
SlAnimation.props = [
  "name",
  "delay",
  "direction",
  "duration",
  "easing",
  "endDelay",
  "fill",
  "iterations",
  "iterationStart",
  "keyframes",
  "playbackRate",
  "pause"
];
SlAnimation.reflect = ["name", "pause"];
SlAnimation.styles = animation_default;
var animation_default2 = SlAnimation;

export {
  animation_default2 as animation_default
};
